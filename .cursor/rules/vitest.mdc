---
description: 
globs: 
alwaysApply: false
---

## TESTING

### Guidelines for UNIT

#### VITEST

- **Use `test` instead of `it`** - In this project, we use `test()` for defining test cases. While `it()` and `test()` are aliases, we standardize on `test()` for consistency.
- **Colocation pattern** - Place test files next to the code they test (e.g., `useDashboardData.ts` and `useDashboardData.test.tsx` in the same directory). This makes tests easier to find and maintain.
- **File extensions** - Use `.test.tsx` for tests that render React components or use JSX, and `.test.ts` for pure logic tests without rendering.
- Leverage the `vi` object for test doubles - Use `vi.fn()` for function mocks, `vi.spyOn()` to monitor existing functions, and `vi.stubGlobal()` for global mocks. Prefer spies over mocks when you only need to verify interactions without changing behavior.
- Master `vi.mock()` factory patterns - Place mock factory functions at the top level of your test file, return typed mock implementations, and use `mockImplementation()` or `mockReturnValue()` for dynamic control during tests. Remember the factory runs before imports are processed.
- Create setup files for reusable configuration - Define global mocks, custom matchers, and environment setup in dedicated files referenced in your `vitest.config.ts`. This keeps your test files clean while ensuring consistent test environments. Global setup is in `src/test/setup.ts`.
- Use inline snapshots for readable assertions - Replace complex equality checks with `expect(value).toMatchInlineSnapshot()` to capture expected output directly in your test file, making changes more visible in code reviews.
- Monitor coverage with purpose and only when asked - Configure coverage thresholds in `vitest.config.ts` to ensure critical code paths are tested, but focus on meaningful tests rather than arbitrary coverage percentages.
- Make watch mode part of your workflow - Run `vitest --watch` during development for instant feedback as you modify code, filtering tests with `-t` to focus on specific areas under development.
- Explore UI mode for complex test suites - Use `vitest --ui` to visually navigate large test suites, inspect test results, and debug failures more efficiently during development.
- Handle optional dependencies with smart mocking - Use conditional mocking to test code with optional dependencies by implementing `vi.mock()` with the factory pattern for modules that might not be available in all environments.
- **Use happy-dom for DOM testing** - This project uses `environment: 'happy-dom'` (configured in `vitest.config.ts`) instead of jsdom. It's faster and more stable for React component tests. Combine with testing-library utilities for realistic user interaction simulation.
- Structure tests for maintainability - Group related tests with descriptive `describe` blocks, use explicit assertion messages, and follow the Arrange-Act-Assert pattern to make tests self-documenting.
- Leverage TypeScript type checking in tests - Enable strict typing in your tests to catch type errors early, use `expectTypeOf()` for type-level assertions, and ensure mocks preserve the original type signatures.
- **Test naming convention** - Use descriptive test names starting with "should" (e.g., `test("should return empty array when no active batches", () => {})`). Group related tests in `describe` blocks by feature area (Success cases, Error handling, Edge cases, etc.).
- **Async testing with React Query** - When testing hooks that use React Query, remember to account for retry attempts (configured as `retry: 2` in hooks). Use `waitFor()` with appropriate timeouts for assertions on async state changes.

